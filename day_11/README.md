# Day 11

**虚函数的应用** <p>
多态是虚函数的主要应用, 除此之外, 虚函数还有其他的应用, 可以用于查看**运行时类型时类型信息(RTTI)**

***运行时类型信息(RTTI)***
- *动态类型转换(dynamic_cast)*
    - 用于将基类类型的指针或引用转换为其子类类型的指针或引用
    - **前提是子类必须从基类多态继承 (即基类至少由一个虚函数)**
    - 动态类型转换会对所需转换的基类指针或引用做检查, 如果其指向的对象的类型与所要转换的目标类型一致, 则转换成功, 否则转换失败
    - 针对指针的动态类型转换, 以**返回空指针(NULL)表示失败**, 针对引用的类型转换, 以抛出 `bad_cast` 异常表示失败
- *`typeid` 操作符*
    - 使用时需包含头文件 `#include <typeinfo>`
    - 返回 `type_info` 类型对象的常引用
        - `type_info` 类的成员函数 `name()`, 返回类型名字符串
        - `type_info` 类支持 `!=` 和 `==` 操作符, 可直接用于**类型相同与否的判断**
    - 当其作用于基类类型的指针或引用的目标对象时
        - 若基类不包含虚函数, `typeid` 所返回类型信息由该指针或引用本身的类型决定
        - 若基类至少包含一个虚函数, 即存在多态继承, `typeid` 所返回类型信息由该指针或引用的实际目标对象的类型决定

**虚析构函数** <p>
***虚析构***
- `delete`一个**指向子类对象的基类指针**
    - 实际被调用的仅仅是**基类**的析构函数
    - 基类的析构函数只负责析构子类对象中的**基类子对象**
    - 基类的析构函数**不会调用**子类的析构函数
    - 在子类中分配的资源将**无法得到释放**
- 如果将基类的析构函数声明为虚函数, 那么实际被调用的将是子类的析构函数
- 子类的析构函数首先释放子类自己的成员, 然后在调用基类的析构函数, 释放该子类对象的基类部分, 最终实现完美的资源释放

***空虚析构函数***
- 没有分配任何动态资源的类, 无需定义析构函数
- 没有定义析构函数的类, 编译器会为其提供一个缺省析构函数, 但**缺省析构函数并不是虚函数**
- 为了保证 `delete` 一个指向子类对象的基类指针时, 能够正确调用子类的析构函数, 就必须把基类的析构函数定义为虚函数, 即便它是一个空函数
- 任何时候, 为基类定义一个虚析构函数总是无害的
- 一个类中, 除了**构造函数**和**静态成员函数**外, 任何函数都可以被声明为虚函数






