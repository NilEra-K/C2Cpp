# Day 07

**深浅拷贝构造与拷贝赋值** <p>
***拷贝构造与拷贝赋值***
- 如果类不提供拷贝构造和拷贝赋值, 编译器将提供默认的拷贝构造和拷贝赋值, 而默认的拷贝构造和拷贝赋值函数, **对于指针型变量都只是复制地址 , 而并不是复制地址指向的数据** , 这将导致浅拷贝的问题
- 为了获得完整意义上的对象副本, **必须自己定义**拷贝构造和拷贝赋值, 针对指针型成员变量做**深拷贝**
- 相对于拷贝构造, 拷贝赋值需要做更多的工作
    - 避免自赋值
    - 释放旧资源
    - 分配新资源
    - 拷贝新内容
    - 返回自引用
- 无论是拷贝构造还是拷贝赋值, 其默认实现对**任何类型的指针成员都是简单的复制地址,** 因此应**尽量避免**使用指针型成员变量
- 出于具体原因考虑, 确实无法实现完整意义上的拷贝构造和拷贝赋值, 可以将他们**私有化**, 以防误用
- 如果为一个类提供了自定义的拷贝构造函数, 那么就**没有理由不提供**一个相同逻辑的拷贝赋值运算符

**类的静态成员** <p>
***静态成员变量***
- 静态成员变量**属于类**, 而**不属于对象**
    - 静态成员不包含在对象中, 进程级生命期
    - 静态成员变量的定义和初始化, 只能在**类的外部**而不能在构造函数中进行
    - 静态成员变量依然受**类作用域**和**访问控制限定符**的约束
    - 静态成员变量, 既可以**通过类**访问, 也可以**通过对象**访问
    - 静态成员变量被该类的所有对象实例所共享

***静态成员函数***
- 静态成员函数**属于类**, 而**不属于对象**
    - 静态成员函数**没有 this 指针**, 也**没有常属性**
    - 静态成员依然受**类作用域**和**访问控制限定符**的约束
    - 静态成员函数, 既可以**通过类**访问, 也可以**通过对象**访问
    - **静态成员函数只能访问静态成员**, 而非静态成员函数既可以访问静态成员, 也可以访问非静态成员

***静态成员***
- 事实上, 类的静态成员变量和静态成员函数, 更像是普通的全局变量和全局函数, 只是多了一层类作用域和访问控制限定符的约束, 相当于具有成员访问属性的全局变量和全局函数

**单例模式(Singleton)**
- 一个类仅有一个实例(对象)
- 将包括, 类的拷贝构造函数在内的所有构造函数私有化, 防止使用者在类的外部创建对象
- 公有静态成员函数 `getInstance()` 是获取对象实例的唯一渠道
- 饿汉式: 无论用不用, 程序启动即创建
- 懒汉式: 用的时候创建, 不用了即销毁



