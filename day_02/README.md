# Day 02

**C++ 复合类型——结构、联合与枚举**
- C++ 的结构
    - 定义结构型变量时, 可以省略 `struct` 关键字
    - 可以定义成员函数, 在结构体中的成员函数内部可以直接访问本结构体的成员, 无需通过 **`.`** 或 **`->`**
- C++ 的联合
    - 定义联合变量时, 可以省略 `union` 关键字
    - 支持匿名联合
- C++ 的枚举
    - 定义枚举型变量时, 可以省略 `enum` 关键字
    - 独立的类型, 和整形之间不能隐式转换

**布尔类型**
- 表示布尔量的数据类型 : `bool`
- 布尔类型的字面值常量 :
    - **`true`** 真
    - **`false`** 假
- 布尔类型的本质 : 单字节整数, 用 `1` 和 `0` 表示真和假
- **任何基本类型都可以被隐式转换为布尔类型 :** 非 `0` 即真, `0` 即假
- **任何复合类型都如何转换为布尔类型? (存疑)**

**函数间关系——重载**
- 重载关系
    - **同一作用域内, 函数名相同, 参数表不同**
    - 根据实参类型和形参类型进行匹配, 调用最匹配的函数
    - 只有**同一作用域**内的**同名函数**才涉及重载的关系, 不同作用域的同名函数涉及的是隐藏关系
    - 形参表是否相同与形参名无关, 与形参的个数以及每个对应形参的类型有关
- 重载解析
    - 完全匹配 > 常量转换 > 升级转换 > 标准转换 > 自定义转换 > 省略号匹配
- 函数指针的类型决定其调用的重载函数的版本

**重载的本质**
- 重载是通过 C++ 的换名机制来实现的
    - 换名机制: <p>
      C++ 国际标准规定, 所有 C++ 函数都必须换名, 所有 C++ 编译器都必须遵守, 但是不同的 C++ 编译器的换名规则都不相同 <p>
      可以使用 `nm filename` 命令来查看可执行文件的符号表, 可以从该符号表中查出这些函数的名称发生了改变 <p>
      ```
        0000000000001272 T _Z3fooPcc
        0000000000001231 T _Z3fooPci
        00000000000011a9 T _Z3fooPcs
        00000000000011ed T _Z3fooPKcs
        00000000000012b5 T _Z3fooz
      ```
- 通过 `extern "C"` 可以要求 C++ 编译器按照 C 方式编译函数, 即不做换名, 当然也就无法重载

**哑元** <p>
只指定形参类型而不指定形参名称的函数, 谓之哑元
- 保证函数的向下兼容
    ```
    void function(int a){
        // 一个算法, 经过迭代后一个参数没有用了
        // 我们可以用哑元:
        // 1. 保证老用户编码不会出错, 保证兼容性
        // 2. 新用户知道这是哑元
        // 函数内部不能获取用户传递的实参数据
    }
    ```
- 形成函数的重载版本

**缺省(默认)参数**
- 可以为函数形参指定缺省(默认)值, 当调用该函数时若未指定实参, 则使用形参的缺省(默认)值
- 如果该函数的某一个形参具有缺省(默认)值, 那么该形参后面的所有形参都必须具有缺省(默认)值
- 尽量避免因为使用缺省参数而导致重载匹配歧义
- 函数形参的缺省(默认)值只能在函数声明中指定

**内联函数**
- 调用普通函数的问题: <p>
    每个普通函数调用语句都需要发生跳转操作, 这种跳转操作会带来时间的开销
- 内联函数实际上就是编译器的一种优化策略 
- 内联函数就是用函数已被编译号的二进制代码, 替换对该函数的调用指令
- 内联保证函数特性的同时, 避免了函数调用的时间开销
- 但是内联函数也存在部分问题:
    - 内联会使可执行文件的体积和进程代码的内存变大, 因此只有**频繁**调用的**简单函数**才适合内联
    - `inline` 关键字仅表示期望该函数被优化为内联函数, 但是是否适合内联完全由编译器决定
    - **稀少**被调用的**复杂函数**和**递归函数**都不适合内联

**动态内存分配**
- C++ 中可以继续使用标准 C库中的 `malloc/free`
- 更建议使用 `new/delete` 操作符再堆中分配/释放内存
    ```
    int* pi = new int;
    delete pi;
    ```
- 在分配内存的同时初始化
    ```
    int* pi = new int(100);
    ```
- 以数组方式 `new` 也要以数组方式 `delete` <p>
    因为以 `new` 方式申请的分配内存时, 一般会多申请 4个字节, 用于存储申请的内存的元素的个数 <p>
    如果使用 `delete pi` 的话只会释放申请使用的内存, 但是多申请的 4个字节并不会释放, 因此会导致**内存泄漏**
    ```
    int* pi = new int[4] {10, 20, 30, 40};
    delete[] pi;
    ```
- 通过 `new` 操作符分配 N维数组, 返回 `N-1` 维数组指针
    ```
    int (*prow)[4] = new int[3][4];
    int (*ppage)[4][5] = new int[3][4][5];
    ```
- 不能通过 `delete` 操作符释放已经释放过的内存
- `delete` 野指针后果**未定义**, `delete` 空指针安全, 未定义结果是非常危险的结果, 会使得在不同的系统中出现不同的问题, 部分错误在 Linux系统中可能是直接杀死, 但是在其他操作系统中可能会出现其他状况
- `new` 操作符申请内存失败, 将**抛出异常**



