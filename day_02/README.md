# Day 02

**C++ 复合类型——结构、联合与枚举** <p>
- C++ 的结构
    - 定义结构型变量时, 可以省略 `struct` 关键字
    - 可以定义成员函数, 在结构体中的成员函数内部可以直接访问本结构体的成员, 无需通过 **`.`** 或 **`->`**
- C++ 的联合
    - 定义联合变量时, 可以省略 `union` 关键字
    - 支持匿名联合
- C++ 的枚举
    - 定义枚举型变量时, 可以省略 `enum` 关键字
    - 独立的类型, 和整形之间不能隐式转换

**布尔类型** <p>
- 表示布尔量的数据类型 : `bool`
- 布尔类型的字面值常量 :
    - **`true`** 真
    - **`false`** 假
- 布尔类型的本质 : 单字节整数, 用 `1` 和 `0` 表示真和假
- **任何基本类型都可以被隐式转换为布尔类型 :** 非 `0` 即真, `0` 即假
- **任何复合类型都如何转换为布尔类型? (存疑)**

**函数间关系——重载** <p>
- 重载关系
    - **同一作用域内, 函数名相同, 参数表不同**
    - 根据实参类型和形参类型进行匹配, 调用最匹配的函数
    - 只有**同一作用域**内的**同名函数**才涉及重载的关系, 不同作用域的同名函数涉及的是隐藏关系
    - 形参表是否相同与形参名无关, 与形参的个数以及每个对应形参的类型有关
- 重载解析
    - 完全匹配 > 常量转换 > 升级转换 > 标准转换 > 自定义转换 > 省略号匹配
- 函数指针的类型决定其调用的重载函数的版本

**重载的本质** <p>
- 重载是通过 C++ 的换名机制来实现的
    - 换名机制: <p>
      C++ 国际标准规定, 所有 C++ 函数都必须换名, 所有 C++ 编译器都必须遵守, 但是不同的 C++ 编译器的换名规则都不相同 <p>
      可以使用 `nm filename` 命令来查看可执行文件的符号表, 可以从该符号表中查出这些函数的名称发生了改变 <p>
      ```
        0000000000001272 T _Z3fooPcc
        0000000000001231 T _Z3fooPci
        00000000000011a9 T _Z3fooPcs
        00000000000011ed T _Z3fooPKcs
        00000000000012b5 T _Z3fooz
      ```
- 通过 `extern "C"` 可以要求 C++ 编译器按照 C 方式编译函数, 即不做换名, 当然也就无法重载

**哑元** <p>
只指定形参类型而不指定形参名称的函数, 谓之哑元
- 保证函数的向下兼容
    ```
    void function(int a){
        // 一个算法, 经过迭代后一个参数没有用了
        // 我们可以用哑元:
        // 1. 保证老用户编码不会出错, 保证兼容性
        // 2. 新用户知道这是哑元
        // 函数内部不能获取用户传递的实参数据
    }
    ```
- 形成函数的重载版本

**缺省(默认)参数** <p>

