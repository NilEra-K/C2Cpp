# Day 12

**异常前导** <p>
***错误与错误处理***
- 何为错误?
    - 语法错误: 程序员在编码阶段解决并通过编译
    - 逻辑错误: 程序员借助于调试工具诊断并修改
    - 功能错误: 程序员修改代码, 测试员回归验证
    - 设计缺陷: 设计员修改设计, 程序员重新编码
    - 需求不符: 分析员修改需求, 设计员重新设计
    - 环境异常: 客服协助用户调整程序的运行环境
    - 操作不当: 客服指导用户按照正确的方法操作
- 错误处理主要针对在实际环境中发生, 却在设计、编码和测试阶段无法预料的, 各种潜在的异常
- 三种典型的错误处理机制
    - 通过返回值返回错误信息
        - 所有局部对象都能被正确的析构
        - 逐层判断, 流程繁琐
    - 借助 `setjump/longjmp` 远程跳转
        - 一步到位, 流程简单
        - 某些局部对象可能因此丧失被析构的机会
    - 抛出——捕获异常对象
        - 形式上一步到位, 流程简单
        - 实际上逐层析构局部对象, 避免内存泄漏

**C++ 异常处理** <p>
***异常处理语法***
- 关于异常处理机制
    - 如果程序中没有捕获异常的代码, 一旦异常被抛出, 最终将被操作系统捕获, 操作系统将程序杀死
    - 如果程序中有捕获异常的代码, 一旦异常被抛出, 将层层退出右花括号, 知道异常被捕获为止, 程序回归正常流程    
- 抛出异常
    - 使用 `throw` 抛出异常
    - `throw 异常对象`
    - 可以抛出基本类型的对象, 如: `throw -1;` 、 `throw "Wrong";`
    - 也可以抛出类类型对象, 如:
        ```
        MemoryException ex;
        throw ex;
        throw MemoryException();
        ```
    - 但不要抛出局部对象的指针, 如:
        ```
        MemoryException ex;
        throw &ex;
        ```
- 捕获异常
    ```
    try {
        可能引发异常的语句;
    }
    catch(异常类型1& ex){
        针对异常类型 1的异常处理;
    }
    catch(异常类型2& ex){
        针对异常类型 2的异常处理;
    }
    ...
    catch(异常类型n& ex){
        针对异常类型 3的异常处理;
    }
    ```
    - 在捕获异常时建议在 `catch` 子句中使用引用接收异常对象, 避免因为拷贝构造带来性能损失
    - 推荐以匿名临时对象的形式抛出异常
    - 异常对象必须允许被拷贝构造和析构, 即**不能私有**拷贝构造函数和析构函数
- 匹配顺序
    - 根据异常对象的类型自上至下顺序匹配, 而非最优匹配, 因此对子类类型异常的捕获不要放在对基类类型异常的捕获后面 **(即最好将对子类的捕获放在对基类对象的捕获前面)**

**异常说明(该机制在 C++ 17版本已经不再支持, 编译时需选择 `-std=c++14` 或更早的版本)**
- 异常说明是函数原型的一部分, 旨在说明函数可能抛出的异常类型
    ```
    返回类型 函数名(形参表) throw(异常类型 1, 异常类型 2, ..., 异常类型 n){
        函数体;
    }
    ```
- 异常说明是一种承诺, 承诺函数不会抛出异常说明以外的异常类型
    - 如果函数抛出了异常说明以外的异常类型, 那么该类型将无法被捕获, 并导致进程终止
    - `std::unexpected() -> std::terminate() -> abort()`
- 隐式抛出异常的函数也可以列出它的异常说明
- 异常说明可以没有也可以为空
    - **没有**异常说明, 表示可能抛出任何类型的异常
        ```
        void foo(void) { ... }
        ```
    - 异常说明为**空**, 表示不会抛出任何类型的异常
        ```
        void foo(void) throw() { ... }
        ```
- 异常说明在函数的声明和定义中必须保持严格一致, 否则将导致编译错误

**异常处理模式**
- 抛出基本类型的异常, 根据异常对象的值分别处理
- 抛出类类型的异常, 根据异常对象的类型分别处理
- 利用类类型的异常, 携带更多诊断信息, 以便查错
- 可以在 `catch` 块中继续抛出所捕获的异常, 或其他异常
    ```
    try{ ... }
    catch (Type& e){
        throw ...;
    }
    ```
- 任何为被捕获的异常, 都会由 `std::unexpected()` 函数处理, 缺省的处理方式就是中止进程
- 忽略异常, 不做处理
    ```
    try{ ... }
    catch (...){ // 忽略异常, 捕获异常不做处理
    }
    ```

**构造函数中的异常**
- 构造函数可以抛出异常, 某些时候还必须抛出异常
    - 构造过程中可能遇到各种错误, 比如内存分配失败
    - 构造函数没有返回值, 无法通过返回值通知调用者
- 构造函数抛出异常, 对象将被不完整构造, 而一个被不完整构造的对象, 其析构函数永远不会被执行
    - 所有对象形式的成员变量, 在抛出异常的瞬间, 都能得到正确的析构( 构造函数的**回滚机制** )
    - 所有动态分配的资源, 必须在抛出异常之前, 自己手动释放, 否则将形成资源的泄漏





