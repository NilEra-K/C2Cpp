# Day 09

**继承**
- 共性和个性: 类与类之间都存在共性和个性, 我们在设计类的时候应抽取共性, 保留个性
- 基类和子类: 抽取共性的类可以称之为基类(父类), 保留个性的类可以称之为子类
- 继承和派生 <p>
子类**继承**基类(父类), 基类**派生**子类
    ```
    class Human {
    public: 
        void eat(const string& food) {...}
        void sleep(int hours) {...}
        string m_name;
        int m_age;
    };

    class Student : public Human {
    public:
        void learn (const string& course){...}
        int m_no;
    };

    class Teacher : public Human {
    public:
        void teach (const string& course){...}
        float m_salary;
    };
    ```
- 继承的语法
    ```
    class 子类 : 继承方式1 基类1, 继承方式2, 基类2, ...{
        ...
    };
    ```
- 继承方式
    - 共有继承: public
    - 保护继承: protected
    - 私有继承: private
- 继承所要达到的目的
    - 子类对象包含基类子对象
    - 子类内部可以直接访问基类的所有非私有成员
- 继承的本质
    - 基类的非私有成员在子类中仅仅为可见, 而非拥有
- **[注意]** 对于继承不要理解为基类的成员变为子类的成员, 继承不会改变类成员的作用域, 基类的成员永远都是基类的成员, 并不会因为继承而变成子类的成员
- **继承的基本特点**
    - 尽管基类的公有和保护成员在子类中直接可见, 但是仍然可以在子类中重新定义这些名字, 子类中的名字会隐藏所有基类中的同名定义 **(可以借助定义表和可见表来进行理解)**
    - 因为作用域不同, 分别在子类和基类中定义的同名成员函数(包括静态成员函数), 并不构成重载关系, 而是一种隐藏关系
    - 如果需要在子类内部访问一个在基类中定义却被子类标识符所隐藏的名字, 可以借助作用域限定符 `::` 实现
    - 任何时候, 在子类内部, 总可以通过作用域限定符 `::` , 显式的调用那些在基类中被定义却被在子类中隐藏的成员
- **三种继承方式的差别**
    - 基类中的公有、保护和私有成员, 在子类中将对这些基类成员的访问控制限定进行重新标记

    | 基类中的 | 在公有子类中被标记为 | 在保护子类中被标记为 | 在私有子类中被标记为 |
    | :-: | :-: | :-: | :-: |
    | 公有成员 | 公有成员 | 保护成员 | 私有成员 |
    | 保护成员 | 保护成员 | 保护成员 | 私有成员 |
    | 私有成员 | 私有成员 | 私有成员 | 私有成员 |
    - 当通过子类访问其所继承的基类成员时, 需要考虑因继承方式堆访问控制限定的影响

**[最常用] 公有继承** <p>
***公有继承的基本特点***
- 子类对象在类外可以访问基类公有成员(其他继承不可以)
    - 如果被子类同名标识符隐藏也可以借助作用域限定符 `::` 指定访问基类的公有成员
- **子类类型的指针或引用** 和 **基类类型的指针或引用** 可以进行转换(其他继承不可以)
    - 子类类型的指针或引用 能**隐式转换**为基类类型
        ```
        class Human {...};
        class Student :public Human {...};
        Student student;
        Human* phuman = &student;
        Human& rhuman = student;
        ```
        编译器认为访问范围缩小是安全的
    - 基类类型的指针或者引用 不能隐式转换为子类类型
        ```
        class Human {...};
        class Student :public Human {...};
        Human human;
        Student* pstudent = static_cast <Student*> (&human);
        Student& rstudent = static_cast <Student&> (human);
        ```
        编译器认为访问范围扩大是危险的
    - 编译器对于类型安全的检测仅仅基于指针或者引用本身
        ```
        class Human {...};
        class Student :public Human {...};
        Student student(...);
        Human* phuman = &student;
        Human& rhuman = student;
        Student* pstudent = static_cast <Student*> (phuman);
        Student& rstudent = static_cast <Student&> (rhuman);
        ```
        基类指针或引用的实际目标, 究竟是不是子类对象, 完全由程序员自己判断

**子类的构造和析构函数** <p>
***子类的构造***
- *子类没有定义构造函数*
    - 编译器为子类提供的默认无参构造函数, 定义基类子对象, 并调用其基类的无参构造函数, 构造该子类对象中的基类子对象
- *子类定义构造函数但没有在初始化表中指明基类部分构造方式*
    - 定义基类子对象, 并调用其基类的无参构造函数, 构造该子类对象中的基类子对象
- *子类定义构造函数并在初始化表中指明基类构造方式*
    - 定义基类子对象并调用指明的其基类的构造函数
- **子类对象的构造过程**
    - 构造基类子对象->构造成员变量->执行构造代码
- **阻断继承(了解即可)**
    - 子类的构造函数无论如何都会调用基类的构造函数, 构造子类对象中的基类子对象
    - 如果把基类的构造函数定义为私有, 那么该类的子对象永远无法被实例化为对象 
    - 在 C++ 中可以用这种方法阻断一个类被扩展

***子类的析构***
- *子类没有定义析构函数*
    - 编译器将提供一个默认析构函数, 析构完所有成员变量以后, 会自动调用其基类的析构函数
- *子类定义析构函数*
    - 子类的析构在执行完自身的析构代码, 并析构完所有的成员变量以后, 会自动调用其基类的析构函数
- 子类对象的析构过程




