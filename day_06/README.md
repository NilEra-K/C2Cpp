# Day 06

**构造函数**
- 函数名必须与类名相同, 且没有返回值类型
- 构造函数调用时间
    - 在定义对象同时自动被调用, 且仅被调用一次
        - 对象定义语句
        - new 操作符
- **构造函数的作用**
    - 定义对象的各个成员变量并赋初值, 设置对象的初始状态
    - 在对象定义之初想实现的任何操作
- 构造函数可以重载
    - 构造函数也可以通过参数表的差别化形成重载
    - 重载的构造函数, 通过构造函数的实参类型进行匹配
    - 不同的构造函数, 表示对象不同的创建方式
    - 使用缺省参数可以减少构造函数重载的数量
- 构造函数的分类
    - 多参构造函数: 按多参方式构造
    - 无参(缺省)构造函数: 按无参方式构造
    - 类型转换构造函数: 利用不同类型的对象构造
    - 拷贝构造函数: 利用相同类型的对象构造

***无参构造函数***
- 无参构造函数亦称缺省构造函数, **但其未必真的没有任何参数**, 为一个有参构造函数的每个参数都提供一个缺省值, 同样可以达到无参构造函数的效果
- 如果一个类没有任何构造函数, 那么编译器会为其提供一个无参构造函数
    - 对*基本类型的成员变量*进行定义, 并初始化为随机数
    - 对*类类型的成员变量*进行定义, **调用相应类型的无参构造函数**
- 如果一个类定义了构造函数, 无论这个构造函数是否带有参数, 编译器都不会再为这个类提供无参构造函数
- 有时**必须**为一个类提供无参构造函数, 仅仅因为它有可能作为另一个类的类类型成员变量

***拷贝构造函数***
- 形态如下的构造称之为拷贝构造函数, 用于利用一个已定义的对象, 来定义其同类型的副本对象, 即**对象克隆**
    ```
    class 类名 {
        // 引用(&) 是为了提高传参效率
        // const 修饰是为了构成万能引用, 是为了接收更多的值
        类名(const 类名& that) {...}
    };
    ```
- 若一个类没有定义拷贝构造函数, 那么编译器会为其提供一个默认的拷贝构造函数
    - 对基本类型成员变量进行定义, 并赋初值(按字节复制)
    - 对类类型成员变量进行定义, 并调用相应类型的拷贝构造函数
- 如果自己定义了拷贝构造函数, 编译器将不再提供默认的拷贝构造函数, 这时所有与成员复制有关的操作, 都必须在自定义拷贝构造函数中自己编写代码完成
- 若默认拷贝构造函数不能满足要求, 则需自己定义
- 拷贝构造函数的调用时机
    - 用已定义对象作为同类型对象的构造实参
    - 以对象形式向函数传递参数
    - 从函数中返回对象
    - 注意: 某些拷贝构造过程会因编译优化而被省略
- *自定义构造函数和编译器定义构造函数*
    | 自定义构造函数 | 编译器定义构造函数 |
    | :-: | :-: |
    | 无 | 缺省构造函数<p>缺省拷贝构造函数 |
    | 除拷贝构造函数以外的 <p> 任何构造函数 | 缺省拷贝构造函数 |
    | 拷贝构造函数 | 无 |
- 所有编译器定义的构造函数, 其访问控制属性均为**公有(public)**

***拷贝赋值函数***
- 形态如下的函数称之为拷贝构造函数, 用于一个已定义的对象给同类型的对象赋值, 即**对象赋值**
    ```
    class 类名 {
        类名& operator= (const 类名& that) {...}
    };
    ```
- 如果一个类没有定义拷贝赋值函数, 那么编译器会为其提供一个默认的拷贝赋值函数
    - 对基本类型成员变量: 值传递(按**字节**复制)
    - 对类类型的成员变量: 调用相应类型的拷贝赋值函数
- 如果自己定义了拷贝赋值函数, 编译器将不再提供默认的拷贝赋值函数, 这时所有与成员复制有关的操作, 都必须在自定义拷贝赋值函数中自己编写代码完成
- 若默认拷贝赋值函数不能满足要求, 则需自己定义

***类型转换构造***
- 形态如下的函数称之为类型转换构造, 用于利用一个已定义的对象, 来定义另一个不同类型的对象, 还可以用于实现从源类型到目标类型的隐式类型转换
    ```
    class 目标类型 {
        目标类型 (const 源类型& src) {...}
    };
    ```
- 程序员使用类型转换构造函数可以进行**自定义类型转换**规则
- 通过 `explicit` 关键字, 可以强制这种通过类型转换构造函数实现的类型转换必须通过 **静态转换(温和强转)** 显式的进行

**初始化表**
- 通过在类的构造函数中使用初始化表, 可以通知编译器该类的成员变量如何被初始化
- **类中的基本类型成员变量**, ***最好*** 在初始化表中显式指明如何初始化, 否则初值不确定
- **类中的类类型成员变量**, ***最好*** 在初始化表中显式指明如何初始化, 否则将调用响应类型的无参构造函数
- 类的**常量性**和**引用型**成员变量, ***必须*** 在初始化表中显式初始化
    - `const int x;` 无意义的写法(会报错), x的初始值是一个随机数且无法被修改
    - `int& x;` 没有参照的引用
- 类的成员变量按其在类中的声明顺序依次被初始化, 而与其在初始化表中的顺序无关

**析构函数**
- 析构函数的函数名就是在**类名**前加 **"~"**, 没有返回值也没有参数, 不能重载
- 在销毁对象之前一刻自动被调用, 其仅被调用一次
    - 对象离开作用域
    - delete 操作符
- **作用: 销毁对象的各个成员变量**
- 如果一个类没有定义析构函数, 那么编译器会为其提供一个默认的析构函数
    - 对基本类型的成员变量, 什么也不做
    - 对类类型的成员变量, 调用相应类型的析构函数
    - 销毁对象的各个成员变量
- 对象的销毁过程
    - 调用析构函数
        - 执行析构函数的代码
        - 调用成员变量的析构函数
        - 释放对象各成员变量所占内存空间
    - 释放整个对象所占用的内存空间
- 通常情况下, 若对象在其声明周期的最终时刻, 并**不持有任何动态分配的资源**, 可以**不定义**析构函数
- 但若对象在其生命周期的最终时刻 , **持有动态资源**, 则**必须自己定义析构函数 , 释放对象所持有的动态资源**
- 析构函数的功能并不局限在释放资源上, 它可以执行我们希望在对象被释放之前执行的任何操作






