/* 必须定义析构函数的情况 */
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <fcntl.h>

using namespace std;

class A {
public:
     A(int i = 0) : m_i(i), m_p(new int), m_f(open("./file", O_CREAT | O_RDWR, 0664)) {
          // int m_i = i;
          // int* m_p = new int;
          // int m_f = open(...);  // 定义 m_f, 初值为文件描述符, 文件表等内核结构(也是动态资源)
     }

     // 默认析构函数
     /* ****************************************
     ~A(){
          // 释放 m_i 本身所占的内存空间
          // 释放 m_p 本身所占的内存空间 -> 内存泄漏
          // 释放 m_f 本身所占的内存空间 -> 内存泄漏
     }
     **************************************** */

     // 因为我们的成员变量存在动态资源 m_p, 成员变量 m_f 还维护有相应的文件描述符所代表的文件信息
     // 所以默认析构函数的操作会导致内存泄漏
     // 此时需要我们自己定义析构函数
     ~A(){
          delete m_p;    // 释放堆内存
          close(m_f);    // 关闭文件描述符
          // 释放 m_i 本身所占的内存空间
          // 释放 m_p 本身所占的内存空间 -> 内存泄漏
          // 释放 m_f 本身所占的内存空间 -> 内存泄漏
     }
private:
     int m_i;
     int* m_p;
     int m_f;  // 文件描述符
};

// 以上代码模拟 类的设计者 (例如: 类库、被人设计的类、自己的设计的类)
///////////////////////////////////////////////////////////
// 以下代码模拟 类的使用者

int main(void){
     A a; // 定义 a, 调用 a.A()
     return 0;
}
