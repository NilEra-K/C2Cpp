# Day 14

**C++ 11 标准**
- C++ 98 的目标: 比 C 强、抽象、OO、泛型
- C++ 03 的目标: 修补 C++ 98 的 Bug 
- C++ 11 的目标: 库、更简单、更高效

**类型推导**
- `auto` 关键字
    - C++ 98 中, `auto` 表示栈变量, 通常省略不写
        ```
        void foo(void){
            int i;      // 表示在栈里分配的
            auto int j; // 也表示在栈里分配的
                        // 写了和不写没区别, 所以几乎没人在 C++ 98 标准使用
        }
        ```
    - C++ 11 中, 给 `auto` 赋予了全新的语义, 表示 **自动类型推导**
        - 既根据对变量进行初始化时所使用的数据的类型, 由编译器自动推导出所定义变量的实际类型
        - 例如:
            ```
            auto i = 10;    // int i = 10;
            auto j = i;     // int j = i;
            ```
- `auto` 类型推断的本质
    - 按照定义独立对象并根据初始化数据的类型进行推导
    - `auto` 无法自动推断 `const`, 只能在 `auto` 的上下文显示指明
    - 如果给出的初始化数据类型为**常量指针**, 则可以自动推导 `const`
- `auto` 和引用联用
    - 按照定义独立对象并根据初始化数据的类型进行推导, 所以不可能推导出引用
    - 除非 `auto` 的上下文指明按照引用推导
    - 若指明按照引用推导并且目标带有常属性, 则可以自动推导 `const`
- `auto` 关键字的使用限制
    - 函数形参类型无法推导(C++ 14 标准支持)
    - 类的成员变量无法推导

**类型计算**
- 类型计算分类
    - **C :** `sizeof` 计算类型的大小
    - **C++:** `typeid` 可以获取类型的信息字符串
    - **C++ 11:** `decltype` 获取参数表达式的类型
    - **[注意]** 类型计算由编译器确定, 并不是运行期确定
- 类型计算与类型推导相比
    - 对类型的确定更加精准
        ```
        const int a = 10;
        auto b = a;         // b 类型推导为 int
        decltype(a) c = a;  // c 类型推导为 const int
        ```
    - 可以做到类型相同但值不同
        ```
        const int a = 10;
        auto b = a;
        decltype(a) c = 100;
        ```
- 三种类型计算的规则
    - 标识符表达式, 直接**取表达式的类型**
        ```
        int a;
        decltype(a) -> int
        ```
    - 函数表达式, 取**函数返回值的类型**
        ```
        int foo(int, int);
        decltype(foo(10, 20)) -> int
        ```
    - 其他表达式, 如果表达式的值为**左值**, 取**该左值引用的类型;** 如果表达式的值为**右值**, 则取**右值本身的类型**
- 返回值(类型)后置——主要应用: **`lambda` 表达式** 的内部实现
    - `auto 函数名 (形参表) -> decltype(表达式)`

**列表初始化** <p>
初始化的方式纷繁复杂——
- 等号初始化 : `int a = 123;`
- 小括号初始化 : `new double(1.23);`
- 构造初始化 : `string c("123");`
- 花括号初始化 : `struct Student d = {"张三", 20, {2003, 10, 13}}`

**列表初始化**是这些初始化方法的统一
- 基本类型、类类型、结构体/联合/枚举类型等等的**单个对象**或**对象数组**, 都可以采用形式完全统一的列表初始化语法进行对象的初始化
- 书写形式 : `类型 对象 {初值表};`
    ```
    int a {123};
    new double {1.23};
    string c {"123"};
    struct Student d {"张三", 20, {2003, 10, 13}};
    float e[] {1.1, 2.2, 3.3};
    ```

**`lambda` 表达式——*前置知识*** <p>
C++ 语法中函数作用域中不能再定义函数, 因此没有所谓的局部函数的概念
```
// 不存在以下写法
void foo(void){
    ...;
    int bar(int x, int y){
        return x + y;
    }
    ...;
    cout << bar(100, 200) << endl;
    ...;
}
```
但函数作用域中可以有类型, 当然也可以有表达式
```
// 存在以下写法
// 编译器针对这种情况(函数内部有类型)的工作方式:
// (1) 先编译函数内部的类型
// (2) 再编译函数体本身的代码
void foo(void){
    class A { ... };

    class B {
    public:
        void bar(){ ... }
    };
}
```
**[补充]** 类的成员有两种: 静态成员和实例成员(包括实例和函数) 
- **实例成员的存储空间属于具体的实例** , 不同实例(对象)的同名成员拥有不同的存储空间
- **静态成员的存储空间是固定的** , 与具体的实例(对象)无关, 被该类的所有实例共享


**`lambda` 表达式** 
- 语法规则
    ```
    // 选项一般直接省略
    [捕获表] (参数表) 选项 -> 返回类型 {
        函数体;
    }
    ```
- **捕获表**
    - `[]` - 不捕获任何外部变量
    - `[variable]` - 捕获外部变量的值(具备只读属性)
    - `[&variable]` - 按引用捕获, 指定的外部变量
    - `[this]` - 捕获 `this` 指针, 访问外部对象的成员
    - `[=]` - 按值捕获所有的外部变量, 也包括 `this`
    - `[&]` - 按引用捕获所有的外部变量, 也包括 `this`
    - `[=, &variable]` - 按值捕获所有的外部变量包括 `this`, 但是指定的外部变量按引用捕获
    - `[&, =variable]` - 按引用捕获所有的外部变量, 也包括 `this`, 但是指定的外部变量按引用捕获
- 表象
    - `lambda` 表达式的名称是一个表达式( **外观类似函数** ), 但本质绝非如此
- 本质
    - `lambda` 表达式**本质上是一个类**
    - 并且最终**返回值是这个类的对象**
    - 因此对 `lambda` 表达式的调用就是对该对象的**函数操作符**的调用
- `lambda` 表达式可以没有返回类型, 将根据 `return` 判断
- `lambda` 表达式可以没有 `return` 语句, 此时返回值为 `void`
- 参数为 `void` 可以省略不写

