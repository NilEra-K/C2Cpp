# Day 14

**C++ 11 标准**
- C++ 98 的目标: 比 C 强、抽象、OO、泛型
- C++ 03 的目标: 修补 C++ 98 的 Bug 
- C++ 11 的目标: 库、更简单、更高效

**类型推导**
- `auto` 关键字
    - C++ 98 中, `auto` 表示栈变量, 通常省略不写
        ```
        void foo(void){
            int i;      // 表示在栈里分配的
            auto int j; // 也表示在栈里分配的
                        // 写了和不写没区别, 所以几乎没人在 C++ 98 标准使用
        }
        ```
    - C++ 11 中, 给 `auto` 赋予了全新的语义, 表示 **自动类型推导**
        - 既根据对变量进行初始化时所使用的数据的类型, 由编译器自动推导出所定义变量的实际类型
        - 例如:
            ```
            auto i = 10;    // int i = 10;
            auto j = i;     // int j = i;
            ```
- `auto` 类型推断的本质
    - 按照定义独立对象并根据初始化数据的类型进行推导
    - `auto` 无法自动推断 `const`, 只能在 `auto` 的上下文显示指明
    - 如果给出的初始化数据类型为**常量指针**, 则可以自动推导 `const`
- `auto` 和引用联用
    - 按照定义独立对象并根据初始化数据的类型进行推导, 所以不可能推导出引用
    - 除非 `auto` 的上下文指明按照引用推导
    - 若指明按照引用推导并且目标带有常属性, 则可以自动推导 `const`
- `auto` 关键字的使用限制
    - 函数形参类型无法推导(C++ 14 标准支持)
    - 类的成员变量无法推导

**类型计算**
- 类型计算分类
    - **C :** `sizeof` 计算类型的大小
    - **C++:** `typeid` 可以获取类型的信息字符串
    - **C++ 11:** `decltype` 获取参数表达式的类型
    - **[注意]** 类型计算由编译器确定, 并不是运行期确定
- 类型计算与类型推导相比
    - 对类型的确定更加精准
        ```
        const int a = 10;
        auto b = a;         // b 类型推导为 int
        decltype(a) c = a;  // c 类型推导为 const int
        ```
    - 可以做到类型相同但值不同
        ```
        const int a = 10;
        auto b = a;
        decltype(a) c = 100;
        ```
- 三种类型计算的规则
    - 标识符表达式, 直接**取表达式的类型**
        ```
        int a;
        decltype(a) -> int
        ```
    - 函数表达式, 取**函数返回值的类型**
        ```
        int foo(int, int);
        decltype(foo(10, 20)) -> int
        ```
    - 其他表达式, 如果表达式的值为**左值**, 取**该左值引用的类型;** 如果表达式的值为**右值**, 则取**右值本身的类型**
- 返回值(类型)后置——主要应用: **`lambda` 表达式** 的内部实现
    - `auto 函数名 (形参表) -> decltype(表达式)`

**列表初始化** <p>
初始化的方式纷繁复杂——
- 等号初始化 : `int a = 123;`
- 小括号初始化 : `new double(1.23);`
- 构造初始化 : `string c("123");`
- 花括号初始化 : `struct Student d = {"张三", 20, {2003, 10, 13}}`

**列表初始化**是这些初始化方法的统一
- 基本类型、类类型、结构体/联合/枚举类型等等的**单个对象**或**对象数组**, 都可以采用形式完全统一的列表初始化语法进行对象的初始化
- 书写形式 : `类型 对象 {初值表};`
    ```
    int a {123};
    new double {1.23};
    string c {"123"};
    struct Student d {"张三", 20, {2003, 10, 13}};
    float e[] {1.1, 2.2, 3.3};
    ```

**lambda 表达式**


