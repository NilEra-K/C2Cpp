# Day 08

**友元**
- 可以通过 `friend` 关键字, 把一个全局函数、另一个类的成员函数或者另一个类整体, 声明为授权类的 **友元**
- 友元拥有访问授权类任何非共有成员的特权
- 友元声明可以出现在授权类的公有、私有或者保护等任何区域, 其不受访问控制限定符的约束
- 友元不是成员, 其作用域不隶属于授权类, 也不拥有授权类类型的 **this 指针**

**操作符重载** <p>
重新定义操作符的运算规则, 一旦重新定义了操作符的规则, 可以使我们自己设计的类型和基本类型一样参与各种运算符的表达式 <p>
例如: 
```
int a = 5, b = 10;
a + b;  // 基本类型, 编译器本身知道按照什么规则做加法

Human ha, hb;
ha + hb;// 自定义类型, 编译器本身不知道按照什么规则做加法, 规则需要由我们来定制
```

**操作符重载的限制**
- 并不是所有操作符都能重载, 以下操作符不能重载
    - 作用域限定操作符 `::`
    - 直接访问成员操作符 `.`
    - 条件操作符 `? :`
    - 字节长度操作符 `sizeof`
    - 类型信息操作符 `typeid`
- 有些操作符可以重载, 但是几乎没有人去重载
    - `new`
    - `delete`

**操作符标记与操作符函数**
- 操作符标记
    - **单目运算符 :** `-` 、 `++` 、 `--` 、 `*` 、 `->` 等
    - **双目运算符 :** `+` 、 `-` 、`>` 、 `<` 、 `+=` 、 `-=` 、 `>>` 、 `<<` 等
    - **三目运算符 :** `? :`
- 操作符函数
    - 在特定条件下, 编译器有能力把一个由操作数和操作符组成的表达式, 解释为对一个全局函数的调用或解释为对一个成员函数的调用, 该全局函数或成员函数被称为操作符函数
        ```
        a + b; -> a.operator+(b) 或 a.operator+(a, b)

        a - b; -> a.operator-(b) 或 a.operator-(a, b)
        ```
    - 通过定义操作符函数, 可以实现针对自定义类型的运算法则, 并使之与内置类型一样参与各种表达式
- 单目操作符表达式(`O`为唯一操作数, `#`为操作符): `#O` / `O#`
    - **成员函数形式 :** `O.operator#()`
    - **全局函数形式 :** `operator#(O)`
- 双目操作符表达式(`L`为左操作数、`R`为右操作数、`#`为操作符): `L # R`
    - **成员函数形式 :** `L.operator#(R)` <p>
      左操作数是调用对象, 右操作数是参数对象
    - **全局函数形式 :** `operator#(L, R)` <p>
      左操作数是第一参数, 右操作数是第二参数
- 三目操作符表达式: F # S # T
    - 无法重载
- **[注意] 成员函数形式和全局函数形式两个只需要提供一个, 否则编译器会报错**

***典型单目操作符重载***
- 运算类单目操作符: **`-` (数值反)** 、 **`~` (按位反)** 、 **`!` (逻辑反)**
    - 操作数可以为**非常左值**、 **常左值** 或 **右值**
    - 表达式结果为右值
- 前自增减类单目操作符: **`++x`** 、 **`--x`**
    - 操作数为非常左值
    - 表达式的结果为**操作数本身**, 而非副本
- 后自增减类单目操作符: **`x++`** 、 **`x--`**
    - 操作数为非常左值
    - 表达式的结果为**右值** , **且为自增减以前的值**
- **在 C 中** , 前++: 先加 1, 再使用; 后++: 先使用, 再加 1 <p>
  **在 C++ 中** , 前++ 和 后++ 都是直接加 1(内部实现和 C 并不相同), 但是 C++ 想让用户感觉 C一样

***典型双目操作符重载***
- 运算类双目操作符: `+`、 `-`、 `*`、 `/`
    - 左右操作数均可以为**非常左值**、 **常左值** 或 **右值**
    - 表达式结果为**右值**
- 赋值类双目操作符: `=`、 `+=`、 `-=`、 `*=`、 `/=`
    - 右操作数可以为**非常左值**、 **常左值** 或 **右值** , 但左操作数必须为非常左值
    - 表达式结构为左操作数本身(而非副本)
- 比较类双目操作符: `>`、 `<`、 `==`、 `<=`、 `>=` 等
    - 左右操作数均可以为**非常左值**、 **常左值** 或 **右值**
    - 表达式结果为 `bool`

***输入输出操作符的重载***
- 输出操作符: `<<`
    - 左操作数为**非常左值**形式的输出流 **(`ostream`)** 对象, 右操作数为左值或右值
    - 表达式的结果为左操作数本身, 而非副本
    - 左操作数的类型为 `ostream` , 若以成员函数形式重载该操作符, 就应将其定义为 `ostream` 类的成员, 该类为标准库提供, 无法添加新的成员, 因此**只能以全局函数形式重载**该操作符
        ```
        ostream& operator<<(ostream& os, const RIGHT& right) { ... }
        ```
- 输入操作符: `>>`
    - 左操作符为**非常左值**形式的输入流 **(`istream`)** 对象, 右操作数为非常左值
    - 表达式的结果为左操作数本身, 而非副本
    - 左操作数的类型为 `istream` , 若以成员函数形式重载该操作符, 就应将其定义为 `istream` 类的成员, 该类为标准库提供, 无法添加新的成员, 因此**只能以全局函数形式重载**该操作符
        ```
        istream& operator>>(istream& is, RIGHT& right) { ... }
        ```

***下标操作符***
- 下标操作符: `[]`
    - 常用于在**容器类型**中以下标方式获取数据元素
    - 非常容器的元素为非常左值, 常容器的元素为常左值

***函数操作符***
- 函数操作符(常称小括号操作符): `()`
    ```
    Human h;
    h(...);     // h.operator()()
    ```
- 用于实现 `lambda` 表达式

***解引用和间接成员访问操作符***
- 解引用和间接成员访问操作符: `*` 、 `->`
    - 如果一个类重载了 "解引用" 和 "间接成员访问操作符", 那么该类的对象就可以被当作指针来使用
- 应用的体现(智能指针)
    - 智能指针的本质就式一个类对象, 并且维护一个指针型成员变量

***类型转换构造符***
- 若源类型是基本类型, 目标类型是类类型, 则只能通过**类型转换构造函数**实现自定义类型转换
    ```
    class 目标类型 {
        目标类型(const 源类型& src) {...}
    };
    ```
- 若目标类型是基本类型, 源目标是类类型, 则只能通过类型转换操作符函数实现自定义类型转换
    ```
    class 源类型 {
        operator 目标类型 (void) const {...}
    };
    ```
- 自定义类型转换
    - 若**源类型和目标类型都是类类型(而非基本类型)**, 则既可以通过类型转换构造函数, 也可以通过类型转换操作符函数实现自定义类型转换, 但是两者不能同时使用
    - 若**源类型和目标类型都是基本类型**, 则无法实现自定义类型转换, 基本类型间的类型转换规则完全由编译器**内置**

***智能指针***
- 常规指针的缺点
    - 当一个常规指针离开它的作用域时, 只有该指针变量本身所占据的内存空间(通常是 8字节)会被释放, 而他所指向的动态内存并未得到释放
    - 必须手动释放
- 智能指针的优点
    - 智能指针是一个类对象(封装了常规指针), 当它离开作用域时, 其析构函数负责释放该常规指针所指向的动态内存
- 智能指针与常规指针的一致性
    - 为了使智能指针也能像常规指针一样, 通过 `*` 操作符解引用, 通过 `->` 操作符访问其目标的成员, 就需要对 `*` 和 `->` 这两个操作符进行重载
- 智能指针与常规指针的不一致性
    - 智能指针的默认拷贝构造和默认拷贝赋值只是简单复制堆对象的地址
    - 当多个智能指针持有同一个堆对象的地址, 该堆对象将在多个智能指针的析构函数中被释放多次(`double free`)
- 愚蠢的解决方法
    - 只允许一个智能指针持有堆对象的地址
    - 自定义拷贝构造和拷贝赋值, 对智能指针所持有的堆对象地址, 以地址间的转移代替复制
    - 智能指针的转移语义与常规指针的复制语义不一致

